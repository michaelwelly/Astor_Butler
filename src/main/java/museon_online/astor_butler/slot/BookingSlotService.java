package museon_online.astor_butler.slot;

import lombok.RequiredArgsConstructor;
import museon_online.astor_butler.location.Location;
import museon_online.astor_butler.location.LocationRepository;
import museon_online.astor_butler.location.util.TimeRange;
import museon_online.astor_butler.table.RestaurantTable;
import museon_online.astor_butler.table.RestaurantTableRepository;
import org.springframework.stereotype.Service;

import java.time.*;
import java.util.*;

@Service
@RequiredArgsConstructor
public class BookingSlotService {

    private final BookingSlotRepository slotRepository;
    private final LocationRepository locationRepository;
    private final RestaurantTableRepository tableRepository;

    public BookingSlot createOrReserveSlot(UUID locationId, UUID tableId, LocalDateTime startTime, LocalDateTime endTime) {
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found"));

        RestaurantTable table = tableRepository.findById(tableId)
                .orElseThrow(() -> new IllegalArgumentException("Table not found"));

        Optional<BookingSlot> existingSlot = slotRepository.findByLocationAndTableAndStartTime(location, table, startTime);

        BookingSlot slot;
        if (existingSlot.isPresent()) {
            slot = existingSlot.get();
            if (slot.getStatus() != BookingSlotStatus.AVAILABLE) {
                throw new IllegalStateException("Slot already reserved");
            }
            slot.setStatus(BookingSlotStatus.RESERVED);
        } else {
            slot = BookingSlot.builder()
                    .location(location)
                    .table(table)
                    .startTime(startTime)
                    .endTime(endTime)
                    .type(SlotType.TABLE)
                    .status(BookingSlotStatus.RESERVED)
                    .isAutoGenerated(false)
                    .build();
        }

        return slotRepository.save(slot);
    }

    public void generateSlotsForDate(Location location, LocalDate date) {
        Map<DayOfWeek, TimeRange> schedule = location.getSchedule();
        TimeRange range = schedule.get(date.getDayOfWeek());

        if (range == null) {
            // Нет рабочего времени на этот день — слоты не создаются
            return;
        }

       List<RestaurantTable> tables = tableRepository.findByLocation(location);

        List<BookingSlot> newSlots = new ArrayList<>();
        LocalTime start = range.getStart();
        LocalTime end = range.getEnd();

        ZonedDateTime zonedStart = ZonedDateTime.of(date, start, location.getTimezone());
        ZonedDateTime zonedEnd = ZonedDateTime.of(date, end, location.getTimezone());

        while (zonedStart.plusHours(2).isBefore(zonedEnd)) {
            for (RestaurantTable table : tables) {
                boolean exists = slotRepository.existsByLocationAndTableAndStartTime(
                        location, table, zonedStart.toLocalDateTime()
                );
                if (exists) continue;

                newSlots.add(BookingSlot.builder()
                        .location(location)
                        .table(table)
                        .type(SlotType.TABLE)
                        .startTime(zonedStart.toLocalDateTime())
                        .endTime(zonedStart.plusHours(2).toLocalDateTime())
                        .status(BookingSlotStatus.AVAILABLE)
                        .isAutoGenerated(true)
                        .build());
            }
            zonedStart = zonedStart.plusMinutes(30); // например, шаг 30 минут
        }

        slotRepository.saveAll(newSlots);
    }

    public void generateTodaySlots() {
        List<Location> locations = locationRepository.findAll();
        LocalDate today = LocalDate.now();
        for (Location loc : locations) {
            generateSlotsForDate(loc, today);
        }
    }

    public void generateSlotsForQuarter(Location location) {
        LocalDate today = LocalDate.now();
        LocalDate end = today.plusMonths(3);

        LocalDate date = today;
        while (!date.isAfter(end)) {
            generateSlotsForDate(location, date);
            date = date.plusDays(1);
        }
    }

    public void generateQuarterForAllLocations() {
        List<Location> locations = locationRepository.findAll();
        for (Location loc : locations) {
            generateSlotsForQuarter(loc);
        }
    }

    public List<BookingSlot> findAvailableSlots(UUID locationId, LocalDate date) {
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found"));

        LocalDateTime from = date.atStartOfDay();
        LocalDateTime to = from.plusDays(1);

        return slotRepository.findAllByLocationAndStatusAndStartTimeBetween(
                location, BookingSlotStatus.AVAILABLE, from, to);
    }

    public Optional<BookingSlot> findNearestAvailableSlot(Location location, LocalDateTime desiredStartTime, SlotType type) {
        return slotRepository.findFirstByLocationAndTypeAndStatusAndStartTimeAfterOrderByStartTimeAsc(
                location, type, BookingSlotStatus.AVAILABLE, desiredStartTime
        );
    }

    public List<BookingSlot> findAllByLocation(UUID locationId) {
        Location location = locationRepository.findById(locationId)
            .orElseThrow(() -> new IllegalArgumentException("Location not found"));
        return slotRepository.findAllByLocation(location);
    }

    public BookingSlot findById(UUID id) {
        return slotRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Slot not found"));
    }

    public BookingSlot updateStatus(UUID id, BookingSlotStatus newStatus) {
        BookingSlot slot = findById(id);
        slot.setStatus(newStatus);
        return slotRepository.save(slot);
    }

    public List<BookingSlot> findByStatusAndLocation(UUID locationId, BookingSlotStatus status) {
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found"));
        return slotRepository.findAllByLocationAndStatus(location, status);
    }

    public void deleteSlot(UUID id) {
        slotRepository.deleteById(id);
    }
}
