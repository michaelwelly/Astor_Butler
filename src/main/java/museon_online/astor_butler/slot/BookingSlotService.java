package museon_online.astor_butler.slot;

import lombok.RequiredArgsConstructor;
import museon_online.astor_butler.location.Location;
import museon_online.astor_butler.location.LocationRepository;
import museon_online.astor_butler.table.RestaurantTable;
import museon_online.astor_butler.table.RestaurantTableRepository;
import museon_online.astor_butler.util.TimeRange;
import org.springframework.stereotype.Service;

import java.time.*;
import java.util.*;

@Service
@RequiredArgsConstructor
public class BookingSlotService {

    private final BookingSlotRepository slotRepository;
    private final LocationRepository locationRepository;
    private final RestaurantTableRepository tableRepository;

    public void generateSlotsForDate(Location location, LocalDate date) {
        Map<DayOfWeek, TimeRange> schedule = location.getSchedule();
        TimeRange range = schedule.get(date.getDayOfWeek());

        if (range == null) {
            // Нет рабочего времени на этот день — слоты не создаются
            return;
        }

       List<RestaurantTable> tables = tableRepository.findByLocation(location);

        List<BookingSlot> newSlots = new ArrayList<>();
        LocalTime start = range.getStart();
        LocalTime end = range.getEnd();

        ZonedDateTime zonedStart = ZonedDateTime.of(date, start, location.getTimezone());
        ZonedDateTime zonedEnd = ZonedDateTime.of(date, end, location.getTimezone());

        while (zonedStart.plusHours(2).isBefore(zonedEnd)) {
            for (RestaurantTable table : tables) {
                boolean exists = slotRepository.existsByLocationAndTableAndStartTime(
                        location, table, zonedStart.toLocalDateTime()
                );
                if (exists) continue;

                newSlots.add(BookingSlot.builder()
                        .location(location)
                        .table(table)
                        .type(SlotType.TABLE)
                        .startTime(zonedStart.toLocalDateTime())
                        .endTime(zonedStart.plusHours(2).toLocalDateTime())
                        .status(BookingSlotStatus.AVAILABLE)
                        .isAutoGenerated(true)
                        .build());
            }
            zonedStart = zonedStart.plusMinutes(30); // например, шаг 30 минут
        }

        slotRepository.saveAll(newSlots);
    }

    public void generateTodaySlots() {
        List<Location> locations = locationRepository.findAll();
        LocalDate today = LocalDate.now();
        for (Location loc : locations) {
            generateSlotsForDate(loc, today);
        }
    }

    public void generateSlotsForQuarter(Location location) {
        LocalDate today = LocalDate.now();
        LocalDate end = today.plusMonths(3);

        LocalDate date = today;
        while (!date.isAfter(end)) {
            generateSlotsForDate(location, date);
            date = date.plusDays(1);
        }
    }

    public void generateQuarterForAllLocations() {
        List<Location> locations = locationRepository.findAll();
        for (Location loc : locations) {
            generateSlotsForQuarter(loc);
        }
    }

    public List<BookingSlot> findAvailableSlots(UUID locationId, LocalDate date) {
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found"));

        LocalDateTime from = date.atStartOfDay();
        LocalDateTime to = from.plusDays(1);

        return slotRepository.findAllByLocationAndStatusAndStartTimeBetween(
                location, BookingSlotStatus.AVAILABLE, from, to);
    }

    public Optional<BookingSlot> findNearestAvailableSlot(Location location, LocalDateTime desiredStartTime, SlotType type) {
        return slotRepository.findFirstByLocationAndTypeAndStatusAndStartTimeAfterOrderByStartTimeAsc(
                location, type, BookingSlotStatus.AVAILABLE, desiredStartTime
        );
    }
}
